# **C++ `function_traits` library**
### A `ltl` library of type traits for introspecting C++ function types:
* Function **return** type and **parameter** types; `R(P...)`
* Existence of **varargs** trailing ellipsis; `R(P...,...)`
* 'Abominable' **cvref** qualifiers and **noexcept** specifier
----
<details><summary>Copyright &copy; 2018 Will Wray. Distributed under the Boost Software License, Version 1.0.</summary>

### <b>Boost Software License - Version 1.0 - August 17th, 2003
```
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
```
(Also at http://www.boost.org/LICENSE_1_0.txt or in accompanying file [LICENSE.md](LICENSE.md))
</b>
</details>
<hr>

<details><summary style="display:inline"><b>Background</b>: P0172R0 Abominable Function Types</summary>

><b>**C++ function types** are the types of plain old C/C++ functions:
<br>e.g.: ` void(), int(), void(int), int(char const*,...)`
>
>C++ function types can also have cvref qualifiers or noexcept specifier:
<br>e.g.: `int() const&, void(int) volatile, void() noexcept`
>
>The standard type trait `std::is_function_v<F>` is true for all such types.
<br>The `std` library does not yet provide other traits for C++ function types,
<br>mainly due to the complications caused by the possible qualifers:

Quoting from [P0172R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html) section 2.1, Definitions:

><dt><i>Abominable function types</i>:</dt>
><dd>Types produced by writing a function type followed by cv-ref qualifiers:</dd>

```cpp
   using regular    = void();
   using abominable = void() const volatile &&;
```
>In the example above, `regular` names a familiar function type [...] no surprises,
<br>`abominable` also names a function type, not a reference type, and
<br>despite appearances, is neither a const nor a volatile qualified type. <br>There is no such thing as a cv-qualified function type in the type system, <br>and the abominable function type is something else entirely.

* P0172R0 **Abominable Function Types** by Alisdair Meredith, Nov 2015
</b></details>



<details><summary style="display:inline"><b>Introduction</b>: A complete set of function traits</summary>

><b>This library provides traits for properties of function types in C++17 and on.
<br>The purpose of the library is to access function signatures and test / set qualifiers.
<br>It is a low level library mostly for writing higher level libraries that touch functions.
>
>[Boost.CallableTraits](https://www.boost.org/doc/libs/develop/libs/callable_traits/doc/html/) implements P0172R0's suggested library interface, extended to
<br>support general Callable types. It is a robust, reviewed library for production use.
>
>This library doesn't provide Callable traits, just a complete set of function traits.
<br>It is an experimental design using some C++2a features.</b>
</details>

<details><summary style="display:inline"><b>Motivation</b>: Provide the 48 signature specializations</summary>

See also [Boost.CallableTraits Motivation](https://www.boost.org/doc/libs/develop/libs/callable_traits/doc/html/index.html#callable_traits.introduction.motivation)

><b>There are 48 function signature specializations required since C++17:</b>
- 12 combinations of cvref qualifiers (4 cv x 3 ref)
- x 2 for possible trailing elipsis (C-style varargs ...)
- x 2 for `noexcept` - part of the function type since C++17.
>
><b>I wanted a trait to copy qualifiers from source to target function types*.
<br>Since all 48 specializations are needed to implement *any* function trait
<br>with full generality, one might as well write a full collection of traits.</b>

(*) Copy traits<blockquote><p>See [P1016R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1016r0.pdf) 'A few additional type manipulation utilities' `copy_*` & `clone_*` traits.
<br>Such traits were not proposed in P0172R0 nor implemented yet in Boost.CallableTraits
<br>(there's an open [issue](https://github.com/boostorg/callable_traits/issues/139) to add a `copy_member_cvref` trait).
 
</details>

<details><summary><b>The 48 specializations</b> (also in P0172, Boost.CallableTraits and cppreference)</summary>

```c++
template<typename T> struct fun;

template<class R, class... P> struct fun<R(P...)> {};
template<class R, class... P> struct fun<R(P...) &> {};
template<class R, class... P> struct fun<R(P...) &&> {};
template<class R, class... P> struct fun<R(P...) const> {};
template<class R, class... P> struct fun<R(P...) const &> {};
template<class R, class... P> struct fun<R(P...) const &&> {};
template<class R, class... P> struct fun<R(P...) volatile> {};
template<class R, class... P> struct fun<R(P...) volatile &> {};
template<class R, class... P> struct fun<R(P...) volatile &&> {};
template<class R, class... P> struct fun<R(P...) const volatile> {};
template<class R, class... P> struct fun<R(P...) const volatile &> {};
template<class R, class... P> struct fun<R(P...) const volatile &&> {};
template<class R, class... P> struct fun<R(P..., ...)> {};
template<class R, class... P> struct fun<R(P..., ...) &> {};
template<class R, class... P> struct fun<R(P..., ...) &&> {};
template<class R, class... P> struct fun<R(P..., ...) const> {};
template<class R, class... P> struct fun<R(P..., ...) const &> {};
template<class R, class... P> struct fun<R(P..., ...) const &&> {};
template<class R, class... P> struct fun<R(P..., ...) volatile> {};
template<class R, class... P> struct fun<R(P..., ...) volatile &> {};
template<class R, class... P> struct fun<R(P..., ...) volatile &&> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile &> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile &&> {};
template<class R, class... P> struct fun<R(P...) noexcept> {};
template<class R, class... P> struct fun<R(P...) & noexcept> {};
template<class R, class... P> struct fun<R(P...) && noexcept> {};
template<class R, class... P> struct fun<R(P...) const noexcept> {};
template<class R, class... P> struct fun<R(P...) const & noexcept> {};
template<class R, class... P> struct fun<R(P...) const && noexcept> {};
template<class R, class... P> struct fun<R(P...) volatile noexcept> {};
template<class R, class... P> struct fun<R(P...) volatile & noexcept> {};
template<class R, class... P> struct fun<R(P...) volatile && noexcept> {};
template<class R, class... P> struct fun<R(P...) const volatile noexcept> {};
template<class R, class... P> struct fun<R(P...) const volatile & noexcept> {};
template<class R, class... P> struct fun<R(P...) const volatile && noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) & noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) && noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const & noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const && noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) volatile noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) volatile & noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) volatile && noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile & noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile && noexcept> {};
```
</details>


<details><summary style="display:inline"><b>Aims</b>: A minimal, forward looking, simple dependency</summary>

- <details><summary style="display:inline">A <b>complete</b> yet <b>minimal</b> set of function type traits</summary><blockquote><p><b>Complete</b>: provide a way to do any query or modification that may be needed;<br>if you see something that is not reasonably easy to do then open an issue.</p><p><b>Minimal</b>: avoid bloat and duplication in the interface (not that easy).<br>Narrow scope, single responsibility - function traits only, no more, no less.</p></blockquote></details>

- <details><summary style="display:inline">In a <b>single header</b>, simple to take as a dependency</summary><blockquote><p><b>Simple dependency</b>: one header (or two), self contained with docs.<br>Mesonbuild example as subproject / git submodule. CMake ToDo.<br>Of course, you can just copy the header(s) or cut-n-paste.</p><p><b>Single header</b>: rather than 'fine-grain' headers per trait.<br>Because each trait has to pull in the full 48 specializations,<br>even if a user may only want one of the many traits,<br>it seems not worth the complexity of providing individual headers<br>(unlikely to improve compile time, code organisation or modularity).</p></blockquote></details>

- <details><summary style="display:inline"><b>Forward looking</b>: to concepts - down with SFINAE!</summary><blockquote><p>Look towards concepts and contraints with no need for SFINAE tricks<br>No concern for backward <b>compatibility</b> or support of old compilers<br><b>Diverge</b> from the P0172R0 suggested interface as appropriate<br>A clean, modern implementation (macro use internally).</p></blockquote></details>

<b>. Non Aims</b>: standard, supported, production-ready

>This is a niche library not meant to be a `std` proposal.
</details>


<details><summary style="display:inline"><b>Examples 1</b>: Member traits vs global traits</summary>

>For function type `F`, class `function<F>` contains the function's traits as members.
<br>For non-function type `T`, `function<T>` is an incomplete class type.
>
>**Member traits** of `function<F>` are a convenient interface for most use cases:
```C++
    #include <ltl/function_trait_class> // member traits only
    static_assert( std::is_void_v<
                       ltl::function<void()>::return_type_t >);
    static_assert( not ltl::function<void()>::is_noexcept() );
```
>Member types need `typename` to disambiguate them as types in some cases:
```c++
    using R = typename ltl::function<void()>::return_type_t;
```
>(`typename` will be needed in fewer cases once we have [P0634](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0634r3.html) 'Down with typename!')
<br>**Global traits** are defined in a separate header (that includes function_trait_class):
```c++
    #include <ltl/function_traits> // member and global traits 
    static_assert( std::is_void_v<
                       ltl::function_return_type_t<void()> >);
    static_assert( not ltl::function_is_noexcept_v<void()> );
```
>Global or namespace-scope traits are conventional for `std` traits etc.
<br>Global traits act as template 'type functions' so work well in generic code.
</details>


<details><summary style="display:inline"><b>Examples 2</b>: Set traits vs add / remove traits</summary>

><b>`set_*` traits are more programmatic than conventional `add_*`, `remove_*` traits.
<br>Setters for cv qualifiers, noexcept and variadic take `bool` template arguments,
<br>Setters for ref qualifiers take `ltl::ref_qual_v` template arguments:
```c++
    using namespace ltl;
    static_assert( function_is_noexcept_v<
                     function<void()>::set_noexcept_t<true> >);
```
Other setters take type arguments, e.g. to change function signature types:
```c++
    static_assert( std::is_same_v< void(),
                     function<int()>::set_return_type_t<void> >);
```
>`set_*_as` traits provide a way to copy properties to the target function type
<br>from a source function type template argument - e.g. to copy cvref qualifiers:
```c++
    static_assert( std::is_same_v< void() &,
                     function<void()>::set_cvref_as_t<int() &> >);
```
>Conventional `add_*`, `remove_*` traits are also provided, taking no arguments:
```c++
    static_assert( std::is_same_v< void(),
                     function<void() const &>::remove_cvref_t >);
```
</b></details>

### [Reference](reference.md)<br>[Design](design.md)

An illustrative example of an application using some function_traits:
```cpp
#include <tuple>
#include "function_traits.hpp"

struct Log0 { int log(char const* fmt) const noexcept; };
struct LogV { int log(char const* fmt,...) const & noexcept; };

template <class C, typename F, typename... Vargs>
int logger(F C::* log_mf, Vargs... vargs) noexcept
{
    static_assert( std::is_function_v<F> );

    static_assert( ltl::function_is_const_v<F> );
    static_assert( ltl::function_is_noexcept_v<F> );
    static_assert( ltl::function_is_variadic_v<F>
                  == bool{sizeof...(vargs)} );

    using R = ltl::function_return_type_t<F>;
    using Ps = ltl::function_args_t<F,std::tuple>;
    using P0 = std::tuple_element_t<0,Ps>;

    static_assert( std::is_same_v< R, int> );
    static_assert( std::is_same_v< P0, char const*> );

    return (C{}.*log_mf)("logger",vargs...);
}

template int logger(decltype(&Log0::log));
template int logger(decltype(&LogV::log),int);
```
