# **C++ `function_traits` library**

## Type traits for properties of C++ function types

* **`R(P...)`** : Function '**signature**'; **return** type **`R`**, **parameter** types **`P...`**, and ...
* `R(P...,`**`...`**`)` : existence of C-style **varargs** (denoted by trailing ellipsis **`...`**)
* `R(P...)` **`noexcept(bool)`** : Function **exception** specification; true | false
* `R(P...)` [**`const`**] [**`volatile`**] [**`&`**|**`&&`**] : Function **cvref** qualifiers

A general function type, with <typename `R`, typename... `P`, bool `X`>:

* `R(P...`[`,...`]`)` [`const`] [`volatile`] [`&`|`&&`] `noexcept(X)`

`function_traits` provides traits for properties of general function types in C++17.  
The main application is in higher level libraries that must handle all function types  
including possibly cvref-qualified function types - the 'abominable'  function types.

----
<details><summary>Copyright &copy; 2018 Will Wray. Distributed under the Boost Software License, V1.0</summary>

### **Boost Software License** - Version 1.0 - August 17th, 2003

```txt
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
```

(Also at [boost.org](http://www.boost.org/LICENSE_1_0.txt) and accompanying file [LICENSE_1_0.txt](LICENSE_1_0.txt))

</details>

----

## **Description | Background | Motivation | Aims**

<details><summary><b>Description</b></summary>

>`function_traits` is a single-header library of traits for C++ function types.  
No more, no less; it does not provide traits for general [Callable](https://en.cppreference.com/w/cpp/named_req/Callable) types -  
(function traits can ease implementation of things like callable traits).
>
>It is an 'alpha' design with an experimental interface, subject to change.  
It targets C++17 on recent gcc / clang / msvc compilers.  
Backwards compatibility, for older compilers or for pre-17, is not a priority.

</details>

<details><summary>C++ function types</summary>

>**C++ function types** include the types of ordinary C/C++ free functions, e.g.:

    int()                 or  auto() -> int
    void() noexcept       or  auto() noexcept -> void
    void(int)             or  auto(int) -> void
    int(char const*,...)  or  auto(char const*,...) -> int

>C++ function types can also have cvref qualifiers:

    int() const&          or auto() const& -> int
    void() && noexcept    or auto() && noexcept -> void
    void(int) volatile    or auto(int) volatile -> void

>Such cvref-qualified function types are an artifact of the C++ type system;  
you cannot declare an ordinary free function with such a type and it is  
forbidden to form a pointer or a reference to a cvref-qualified function type.
>
>The standard type trait `std::is_function_v<F>` is true for all such types.  
>  
>The `std` library does not (yet) provide other traits for C++ function types,  
mainly due to the complications caused by the possible cvref qualifers,  
so this library fills in for the lack of std traits.
</details>

<details><summary><b>Background</b>: P0172R0 Abominable Function Types</summary>

Quoting from [P0172R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html) section 2.1, Definition:

>[...] an *abominable* function type is the type produced by writing a function type  
followed by a cv-ref qualifier.

Example:

```cpp
   using regular    = void();
   using abominable = void() const volatile &&;
```

>In the example above, `regular` names a familiar function type [...] no surprises,  
`abominable` also names a function type, not a reference type, and  
despite appearances, is neither a const nor a volatile qualified type.  
There is no such thing as a cv-qualified function type in the type system,  
and the abominable function type is something else entirely.

* P0172R0 **Abominable Function Types** by Alisdair Meredith, Nov 2015

</details>

<details><summary>Boost.CallableTraits: A P0172 implementation and more</summary>

>[Boost.CallableTraits](https://www.boost.org/doc/libs/develop/libs/callable_traits/doc/html/) implements P0172R0's suggested library interface,  
extended to support general [Callable](https://en.cppreference.com/w/cpp/named_req/Callable) types on top of C++ function types.  
It is a robust, reviewed library with tests, compatibility matrix and CI.

</details>

<details><summary><b>Motivation</b>: Provide the 24 (or 48) required specializations</summary>

See also [Boost.CallableTraits Motivation](https://www.boost.org/doc/libs/develop/libs/callable_traits/doc/html/index.html#callable_traits.introduction.motivation)

>'Abominable' function cvref qualifiers cannot be deduced concisely.  
C-style varargs - a trailing ellipsis ... - cannot be deduced concisely.  
A total of 24 separate template specializations are needed to match  
a possibly abominable or variadic function type:

* 12 combinations of cvref qualifiers (4 cv x 3 ref)
* x 2 for presence of C-style varargs (trailing ellipsis...)

>If `noexcept` is not deduced directly then 48 specializations are needed:  

* x 2 for `noexcept` true or false

>### Copy traits
>I wanted a trait to copy qualifiers from source to target function types<sup>1</sup>.  
Since all 24/48 specializations are needed to implement *any* function trait  
with full generality, one might as well write a full collection of traits.
>
>[1] C++ standard library `copy_*` traits are proposed in [P1016](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1016r0.pdf)  
'A few additional type manipulation utilities' (unlikely to be voted in).  
Copy traits like this are not implemented yet in Boost.CallableTraits  
though there's an open [issue](https://github.com/boostorg/callable_traits/issues/139) to add a `copy_member_cvref` trait.
>
>This function_traits library provides a couple of options:  
>`function_set_cvref_as<F,G>` copies `G`'s cvref qualifiers to `F`, or  
`function_set_signature<G, function_signature_t<F>>`  
copies `G`'s cvref qualifiers and exception spec to `F`

</details>

<details><summary>The 24 (or 48) function pattern specializations</summary>

24 template specializations are required to match any function type pattern  
(assuming that `noexcept` is deducible in partial specializations - see note below):

```c++
// Primary template
template<typename T> struct fun;

// The 24 template partial specializations
// to match cvref qualifiers (x12) and presence of varargs (x2)
// while deducing return type R, parameters P... and noexcept(bool)
template<class R, class... P, bool X> struct fun<R(P...) noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) & noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) && noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) const noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) const & noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) const && noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) volatile noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) volatile & noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) volatile && noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) const volatile noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) const volatile & noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P...) const volatile && noexcept(X)> {};

template<class R, class... P, bool X> struct fun<R(P..., ...) noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) & noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) && noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) const noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) const & noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) const && noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) volatile noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) volatile & noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) volatile && noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) const volatile noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) const volatile & noexcept(X)> {};
template<class R, class... P, bool X> struct fun<R(P..., ...) const volatile && noexcept(X)> {};
```

Both GCC and Clang deduce noexcept as intended...  
Unfortunately, when `noexcept` was introduced as part of the type system  
the standard was not also updated to specify deduction of noexcept.  
This oversight should be corrected by a defect report before C++2a.

Currently (start of 2019) MSVC does not deduce noexcept and so requires  
the noexcept cases to be expanded via 48 specializations:

```c++
template<class R, class... P> struct fun<R(P...)> {};
template<class R, class... P> struct fun<R(P...) &> {};
template<class R, class... P> struct fun<R(P...) &&> {};
template<class R, class... P> struct fun<R(P...) const> {};
template<class R, class... P> struct fun<R(P...) const &> {};
template<class R, class... P> struct fun<R(P...) const &&> {};
template<class R, class... P> struct fun<R(P...) volatile> {};
template<class R, class... P> struct fun<R(P...) volatile &> {};
template<class R, class... P> struct fun<R(P...) volatile &&> {};
template<class R, class... P> struct fun<R(P...) const volatile> {};
template<class R, class... P> struct fun<R(P...) const volatile &> {};
template<class R, class... P> struct fun<R(P...) const volatile &&> {};
template<class R, class... P> struct fun<R(P..., ...)> {};
template<class R, class... P> struct fun<R(P..., ...) &> {};
template<class R, class... P> struct fun<R(P..., ...) &&> {};
template<class R, class... P> struct fun<R(P..., ...) const> {};
template<class R, class... P> struct fun<R(P..., ...) const &> {};
template<class R, class... P> struct fun<R(P..., ...) const &&> {};
template<class R, class... P> struct fun<R(P..., ...) volatile> {};
template<class R, class... P> struct fun<R(P..., ...) volatile &> {};
template<class R, class... P> struct fun<R(P..., ...) volatile &&> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile &> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile &&> {};

template<class R, class... P> struct fun<R(P...) noexcept> {};
template<class R, class... P> struct fun<R(P...) & noexcept> {};
template<class R, class... P> struct fun<R(P...) && noexcept> {};
template<class R, class... P> struct fun<R(P...) const noexcept> {};
template<class R, class... P> struct fun<R(P...) const & noexcept> {};
template<class R, class... P> struct fun<R(P...) const && noexcept> {};
template<class R, class... P> struct fun<R(P...) volatile noexcept> {};
template<class R, class... P> struct fun<R(P...) volatile & noexcept> {};
template<class R, class... P> struct fun<R(P...) volatile && noexcept> {};
template<class R, class... P> struct fun<R(P...) const volatile noexcept> {};
template<class R, class... P> struct fun<R(P...) const volatile & noexcept> {};
template<class R, class... P> struct fun<R(P...) const volatile && noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) & noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) && noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const & noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const && noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) volatile noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) volatile & noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) volatile && noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile & noexcept> {};
template<class R, class... P> struct fun<R(P..., ...) const volatile && noexcept> {};
```

These specializations are also listed in [Boost.CallableTraits](https://www.boost.org/doc/libs/develop/libs/callable_traits/doc/html/index.html#callable_traits.introduction.motivation) and [cppreference](https://en.cppreference.com/w/cpp/types/is_function) `is_function`

</details>

<details><summary><b>Aims</b>: A complete, minimal, forward looking, simple dependency</summary>

* <details><summary>A <b>complete</b> yet <b>minimal</b> set of function type traits</summary>

    **Complete**: provide a way to do any query or modification that may be needed;  
    if you see something that is not reasonably easy to do then open an issue.

    **Minimal**: avoid bloat and duplication in the interface (not that easy).  
    Narrow scope, single responsibility - function traits only, no more, no less.
    </details>

* <details><summary>In a <b>single header</b>, simple to take as a dependency</summary>

    **Simple dependency**: single header, self contained with docs.  
    Mesonbuild example as subproject / git submodule. CMake ToDo.  
    Of course, you can just copy the header or cut-n-paste.

    **Single header**: rather than 'fine-grain' headers per trait.  
    Because each trait has to pull in the full 24 (or 48) specializations,  
    even if a user may only want one of the many traits,  
    it seems not worth the complexity of providing individual headers  
    (unlikely to improve compile time, code organisation or modularity).
    </details>

* <details><summary><b>Forward looking</b>: to concepts - down with SFINAE!</summary>

    Look towards concepts and contraints with no need for SFINAE tricks  
    No concern for backward **compatibility** or support of old compilers  
    **Diverge** from the P0172R0 suggested interface as appropriate  
    A clean, modern implementation (macro use confined to header).
    </details>

* **Non Aims**: standard, supported, production-ready

    This is a niche library not meant to be a `std` proposal.
</details>

## [Reference | Design Notes](reference.md)

## **Examples**

<details><summary>Predicate traits and type property traits</summary>

>Test if a function type is const / cvref / noexcept:  

```c++
  #include <ltl/function_traits.hpp>

  using FVCX = void() const noexcept;

  static_assert(
          ltl::function_is_const_v< FVCX >
       && ltl::function_is_cvref_v< FVCX >
       && ltl::function_is_noexcept_v< FVCX >
  );
```

>Get the return type of a function type and a type-list of its parameter types:

```c++
  #include <tuple>
  #include <type_traits>

  using FVFB = void( char, bool() );

  static_assert(
     std::is_void_v< ltl::function_return_type_t< FVFB > >
  && std::is_same_v< ltl::function_args_t< FVFB, std::tuple >
                   , std::tuple< char, bool(*)() >
     >
  );
```


</details>

<details><summary>Add / remove traits and set traits</summary>

>Conventional `add_*`, `remove_*` traits modify the given property `*`.  
They take no arguments beyond the function type to modify:

```c++
  using namespace ltl;
  static_assert(
      std::is_same_v< function_add_const_t<void() &>,
                                           void() const& >
      std::is_same_v< function_remove_cvref_t<void() const &>,
                                              void() >
  );
```

>Some property traits act as `remove_*` traits; the 'signature' property trait  
effectively removes both cvref and noexcept:

```c++
  static_assert(
      std::is_same_v< function_signature_t<void() & noexcept>,
                                           void() >
  );
```

>`set_*` traits are more programmatic than `add_*` and `remove_*` traits.  
Setters for function cv qualifiers, noexcept and variadic take `bool` arguments:

```c++
  static_assert( function_is_noexcept_v<
                    function_set_noexcept_t<void(), true> >);
```

>Setters for reference qualifiers take `ltl::ref_qual_v` arguments  
(an enum type with values `lval_ref_v`, `rval_ref_v` or `ref_qual_v{}`)

```c++
    static_assert(
       std::is_same_v< function_set_reference_t<void() &, rval_ref_v>
                                                void() && >
    );
```

>There are no `add` traits for function reference qualifiers because the 'add'  
in `std::add_rvalue_reference` imples reference collapse such that 'adding'  
an rvalue reference to an lvalue reference gives an lvalue reference; `&` + `&&` => `&`  
(reference collapse is not necessarily natural for function reference qualifiers).  
Instead, there are `function_set_reference_lvalue` / `_rvalue` traits  
(read as "given a function type, set its reference qualifier to lvalue reference")  
(unlike other setters, they take no arguments).

>Setters for type properties take type arguments; to change function return type:

```c++
    static_assert(
       std::is_same_v< function_set_return_type_t<int(), void>,
                                                  void() >);
```

>`set_*_as` traits provide a way to copy properties to the target function type  
from a source function type template argument - e.g. to copy cvref qualifiers:

```c++
    static_assert( std::is_same_v<
                     function_set_cvref_as_t<void() const, int() &>,
                                             void() & >);
```

</b></details>

### A small example of function_traits usage

<details><summary>A somewhat contrived example...</summary>

An illustrative example that type-checks logger member functions,  
with `printf`-like signature that may or may not be variadic, then forwards  
a C++ argument pack to the C varargs (the vargs are not type checked here -  
they could be matched at compile time against the format string...).

```cpp
#include <tuple>
#include "function_traits.hpp"

struct Log0 { int log(char const* fmt) const noexcept; };
struct LogV { int log(char const* fmt,...) const & noexcept; };

template <class C, typename F, typename... Vargs>
int logger(F C::* log_mf, Vargs... vargs) noexcept
{
    static_assert( std::is_function_v<F> );

    static_assert( ltl::function_is_const_v<F> );
    static_assert( ltl::function_is_noexcept_v<F> );
    static_assert( ltl::function_is_variadic_v<F>
                  == bool{sizeof...(vargs)} );

    using R = ltl::function_return_type_t<F>;
    using Ps = ltl::function_args_t<F,std::tuple>;
    using P0 = std::tuple_element_t<0,Ps>;

    static_assert( std::is_same_v< R, int> );
    static_assert( std::is_same_v< P0, char const*> );

    return (C{}.*log_mf)("logger",vargs...);
}

template int logger(decltype(&Log0::log));
template int logger(decltype(&LogV::log),int);
```

</details>
